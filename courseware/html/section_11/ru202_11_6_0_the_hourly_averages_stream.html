<style type= text/css>
   .code {font-family: 'courier new', courier; font-weight: bold; font-size: 18px !important;}
</style>
<p>We should now look at the hourly averages stream that the aggregating consumer writes to.</p>
<p>Unlike the partitioned raw temperature streams, this one doesn't expire.  Instead, its length is managed by the aggregating consumer which trims it to approximately 120 entries every time a new message is written.  This is achieved using the <span class="code">MAXLEN</span> and <span class="code">~</span> modifiers to the <span class="code">XADD</span> command.</p>
<p>In a <span class="code">redis-cli</span> session, you can check on the stream's length to make sure it's about where we expect it to be:</p>
<p><pre class="code">
127.0.0.1:6379> XLEN temps:averages
(integer) 138
</pre></p>
<p>Remember, Redis is trimming the length of this stream to approximately the 120 entries that we asked for, and will only trim the underlying radix tree when an entire node can be deleted.  This means that the actual value shown may be slightly higher.  If you see a value lower than 120, your consumers won't have got more than 120 hours through the data yet.</p>
<p>Finally, let's look at the messages themselves, again using <span class="code">redis-cli</span>:</p>
<p><pre class="code">
127.0.0.1:6379> XREVRANGE temps:averages + - COUNT 2
1) 1) "1557157263124-0"
   2) 1) "hour"
      2) "22"
      3) "date"
      4) "2025/01/10"
      5) "average_temp_f"
      6) "41"
      7) "num_observations"
      8) "3600"
2) 1) "1557157262319-0"
   2) 1) "hour"
      2) "21"
      3) "date"
      4) "2025/01/10"
      5) "average_temp_f"
      6) "47"
      7) "num_observations"
      8) "3600"
</pre></p>
<p>One thing to note about these messages is that their IDs, while timestamps, do not relate to the time period that the data in the message payloads refers to.  These timestamps were auto-generated by <span class="code">XADD</span> when the aggregating consumer put the messages on the stream.</p>